#include <stdio.h>
#include <stdlib.h>

#include "textread.h"

textread_t *
textread_create (const char *csvlog_dir, const char *csvlog_prefix, const char *srcid)
{
    textread_t *tr = calloc (1, sizeof (*tr));
    *tr = (textread_t) {
        .mutable = true,
        .csvlog_prefix = strdup (csvlog_prefix),
        .csvlog_dir  = strdup (csvlog_dir),
        .srcid = strdup (srcid),
        .lvalue = calloc (TEXTREAD_MAX_NFIELDS, sizeof (char *)),
        .rvalue = calloc (TEXTREAD_MAX_NFIELDS, sizeof (char *)),
        .textread_string = g_string_sized_new (4096),
        .csvheader_string = g_string_sized_new (4096),
        .const_string = g_string_sized_new (4096),
    };
    return tr;
}

void
textread_destroy (textread_t *tr)
{
    if (tr) {
        if (tr->csvlog_fid)
            fclose (tr->csvlog_fid);

        g_free (tr->csvlog_prefix);
        g_free (tr->csvlog_dir);
        g_free (tr->csvlog_fname);
        g_free (tr->srcid);

        g_string_free (tr->textread_string, TRUE);
        g_string_free (tr->csvheader_string, TRUE);
        g_string_free (tr->const_string, TRUE);

        for (int i=0; i<tr->nfields; i++) {
            g_free (tr->lvalue[i]);
            g_free (tr->rvalue[i]);
        }
        g_free (tr->lvalue);
        g_free (tr->rvalue);

        g_free (tr);
    }
}

char *
textread_format (const char *format)
{
    if (strchr (format, 's'))
        return strdup (format);
    else if (strchr (format, 'c'))
        return strdup (format);
    else // number
        return strdup ("%n");
}

void
textread_start (textread_t *tr)
{
    if (tr->mutable) {
        char csvlog_fname[NAME_MAX];
        if (strlen (tr->csvlog_prefix))
            snprintf (csvlog_fname, sizeof csvlog_fname, "%s-%s.csv", tr->csvlog_prefix, tr->srcid);
        else
            snprintf (csvlog_fname, sizeof csvlog_fname, "%s.csv", tr->srcid);
        tr->csvlog_fname = strdup (csvlog_fname);

        char fullpath[PATH_MAX];
        sprintf (fullpath, "%s/%s", tr->csvlog_dir, tr->csvlog_fname);
        tr->csvlog_fid = fopen (fullpath, "w");
        if (!tr->csvlog_fid) {
            ERROR ("fopen (%s, \"w\") failed", fullpath);
            exit (EXIT_FAILURE);
        }
    }
}

void
textread_stop (textread_t *tr)
{
    if (tr->mutable) {
        tr->mutable = false;

        /* generate matlab textread cmd */
        g_string_printf (tr->textread_string, "[");
        for (int i=0; i<tr->nfields; i++)
            g_string_append_printf (tr->textread_string, "nav_t.%s.%s,", tr->srcid, tr->lvalue[i]);
        g_string_truncate (tr->textread_string, tr->textread_string->len-1); /* backup over last comma */
        g_string_append_printf (tr->textread_string, "]=textread('%s','", tr->csvlog_fname);
        for (int i=0; i<tr->nfields; i++)
            g_string_append_printf (tr->textread_string, "%s", tr->rvalue[i]);
        g_string_append_printf (tr->textread_string, "','headerlines',2,'delimiter',';');");
        fprintf (tr->csvlog_fid, "%s\n", tr->textread_string->str);

        /* csv header tags */
        for (int i=0; i<tr->nfields; i++)
            g_string_append_printf (tr->csvheader_string, "%s;", tr->lvalue[i]);
        fprintf (tr->csvlog_fid, "%s\n", tr->csvheader_string->str);
    }
    else
        fprintf (tr->csvlog_fid, "\n");
}

void
textread_gen_matlab (textread_t *tra[], size_t tra_len, const char *mfile_dir, const char *mfile_fname)
{
    char mfile_fullname[PATH_MAX];
    sprintf (mfile_fullname, "%s/%s.m", mfile_dir, mfile_fname);

    FILE *fid = fopen (mfile_fullname, "w");
    if (!fid) {
        ERROR ("fopen (%s, \"w\") failed", mfile_fullname);
        exit (EXIT_FAILURE);
    }

    fprintf (fid, "function nav_t = %s()\n", mfile_fname);
    fprintf (fid, "%% lcmlog-export autogenerated loader file %%\n");
    for (int i=0; i<tra_len; i++) {
        if (!tra[i]->mutable) {
            fprintf (fid, "\n%%%s\n", tra[i]->srcid);
            fprintf (fid, "%s\n", tra[i]->textread_string->str);
            if (tra[i]->const_string->len)
                fprintf (fid, "%s\n", tra[i]->const_string->str);
        }
        else {
            ERROR ("%s: textread_t tra is mutable, call textread_stop() first", mfile_fullname);
            exit (EXIT_FAILURE);
        }
    }
    fclose (fid);
}
